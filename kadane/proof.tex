
\section{Proof of Correctness}

\noindent Let's rigorously prove Kadane's algorithm using a loop invariant. \newline 

\noindent \textbf{Loop Invariant:} At the start of iteration \texttt{k} of the loop, \texttt{dp[k-1]} should contains the maximum possible sum for all subarrays ending at index \texttt{k-1}. \newline

\noindent \textbf{Initialization:} Before the first iteration of the loop, \texttt{dp[0]} is initialized to \texttt{arr[0]} as the maximum possible subarray sum as the non-empty condition makes it so that we have to choose atleast one element to be part of our subarray. \newline

\noindent \textbf{Maintenance:} Assume that the loop invariant holds at the start of the iteration $k$. Then, it must be that \texttt{dp[k-1]} contains the maximum sum of all subarrays that is possible if the given subarray ends at index \texttt{k-1}. In the body of the for loop, we calculate the maximum possible subarray sum using the information contained in \texttt{dp[k-1]}. Exactly how this is done can be elaborated upon by taking cases as to what the answer to this value, basically \texttt{dp[k]}, can be. At iteration \texttt{k}, there are two possibilities for the maximum subarray sum ending at iteration \texttt{k}: \newline 

\noindent \underline{case 1:} use an already started subarray and append the current number \texttt{arr[k]} to this sum to continue the subarray \newline 

\noindent The sum in this case would just be \texttt{dp[k-1]+arr[k]} as to append \texttt{arr[k]} to the subarray continuing from the previous index, i.e., \texttt{k-1}.

\noindent \newline \underline{case 2:} don't use an already started subarray - start a new subarray \newline

\noindent In this case, as \texttt{arr[k]} would be the only number in this particular subarray, the subarray sum will just be \texttt{arr[k]}. \newline

\noindent As we wish to find the maximum possible subarray sum, we take the maximum possible value out of these two possible values. This maximum is taken and reassigned to \texttt{dp[k]}. Hence, \texttt{dp[k]} now contains the maximum subarray sum terminating at index \texttt{k} - thus, the loop invariant is re-established for the subsequent iteration. 
\newline

\noindent \textbf{Termination:} When the for loop terminates, \texttt{k} = $(n-1)+1 = n$. Thus, the loop invariant gives us that \texttt{dp[i]} gives us the maximum subarray sum for all subarrays ending at $\texttt{i} \text{  } \forall \text{  } \texttt{i} \in [0, n)$. Finding the maximum of all of these values will give us our answer. This is what \texttt{globalMaxi} tracks and is our final answer, namely the maximum sum of all possible subarrays.
